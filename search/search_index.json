{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction NeoDB is a free and open source integrated M.tuberculosis (M.tb) \u2018omics\u2019 knowledge-base. NeoDB is based on Neo4j and enables researchers to execute complex federated queries by linking well-known, curated and widely used M.tb data resources, and supplementary TB variants data from published literature. NeoDB was created by binding the labeled property graph model to a consensus-controlled ontology. Motivation Tuberculosis (TB) is a significant global health threat, with one-third of the population infected with its causative agent Mycobacterium tuberculosis (M.tb) . Its mortality rate declined by 37% between 2000 and 2016, however, this period also saw an exponential growth in multi drug resistant TB (MDR-TB) and extensively drug resistant TB (XDR-TB) ( WHO., 2017 ). Globally, researchers have been responding with a plethora of heterogeneous TB databases with each focusing on different subsets of TB data and present limited options for data integration thus impeding the chances of integrative analysis. Although each database can provide answers to certain questions in its scope, it falls short in answering questions that require federated queries across multiple domains of biological knowledge. The availability of different M.tb genomes and omics datasets require a computational platform that can seamlessly integrate a range of data. Integrating these fragmented biological resources is essential for the discovery of new associations between datasets or the validation of existing hypotheses. This necessitates effective and efficient management, storage, analysis and visualization of the data and results through development of novel and customized bioinformatics software tools and databases. NeoDB Graph Model","title":"Welcome to NeoDB's documentation!"},{"location":"#introduction","text":"NeoDB is a free and open source integrated M.tuberculosis (M.tb) \u2018omics\u2019 knowledge-base. NeoDB is based on Neo4j and enables researchers to execute complex federated queries by linking well-known, curated and widely used M.tb data resources, and supplementary TB variants data from published literature. NeoDB was created by binding the labeled property graph model to a consensus-controlled ontology.","title":"Introduction"},{"location":"#motivation","text":"Tuberculosis (TB) is a significant global health threat, with one-third of the population infected with its causative agent Mycobacterium tuberculosis (M.tb) . Its mortality rate declined by 37% between 2000 and 2016, however, this period also saw an exponential growth in multi drug resistant TB (MDR-TB) and extensively drug resistant TB (XDR-TB) ( WHO., 2017 ). Globally, researchers have been responding with a plethora of heterogeneous TB databases with each focusing on different subsets of TB data and present limited options for data integration thus impeding the chances of integrative analysis. Although each database can provide answers to certain questions in its scope, it falls short in answering questions that require federated queries across multiple domains of biological knowledge. The availability of different M.tb genomes and omics datasets require a computational platform that can seamlessly integrate a range of data. Integrating these fragmented biological resources is essential for the discovery of new associations between datasets or the validation of existing hypotheses. This necessitates effective and efficient management, storage, analysis and visualization of the data and results through development of novel and customized bioinformatics software tools and databases.","title":"Motivation"},{"location":"#neodb-graph-model","text":"","title":"NeoDB Graph Model"},{"location":"example-cypher-queries/","text":"Cypher Cypher is a declarative graph query language that allows for expressive and efficient querying and updating of the graph. Cypher is designed to be simple, yet powerful; highly complicated database queries can be easily expressed, enabling you to focus on your domain, instead of getting lost in database access. Point your browser to localhost:7474 to access the Neo4j browser. On cold boot, Neo4j has nothing cached yet, and needs to go to disk for all records. Once records are cached, you will see greatly improved performance. One technique that is widely employed is to \u201cwarm the cache\u201d. To warm the cache to improve performance from cold start, run: CALL apoc.warmup.run This will load all nodes and relationships into memory. To view the schema, run: call db.schema.visualization Example Cypher Queries Exploring COMBAT-TB NeoDB Label count In Neo4j, node types are called labels. The following query counts the number of nodes per label. MATCH(node) RETURN head(labels(node)) AS label, count(*) AS count ORDER BY count DESC Relationship type count The following query counts the number of relationships per type MATCH()-[rel]->() RETURN type(rel) AS rel_type, count(*) AS count ORDER BY count DESC Random relationships The following query retrieves a random relationship of each type. The query goes through every relationship and thus may take several seconds. MATCH()-[rel]->() WITH type(rel) AS rel_type, collect(rel) AS rels WITH rels[toInteger(rand() * size(rels))] AS rel RETURN startNode(rel), rel, endNode(rel) Querying COMBAT-TB NeoDB Genes that encode protein, limiting to results to 25 The following query finds genes that encode protein. MATCH(g:Gene)-[r:ENCODES]->(p:Protein) RETURN g.name as gene, p.name as protein LIMIT 25 Genes that encode a protein that interacts with a known drug target The following query finds proteins that interact with known drug targets. MATCH p=(gene:Gene)-[:ENCODES]-(p1:Protein)-[i:INTERACTS_WITH]-(p2:Protein)-[:TARGET]-(drug:Drug) RETURN gene.name as Gene, i.score as Score, p2.uniquename as Interactor, drug.name as Drug ORDER BY Score DESC Find proteins that interact with a certain protein The following query finds proteins that interact with a protein that has O06295 as the uniquename or UniProtId. MATCH p=(:Protein {uniquename:'O06295'})-[r:INTERACTS_WITH]-(:Protein) RETURN p Find the top 10 proteins that interact with a specific protein sorted by score The following query finds the top 10 proteins that interact with a protein that has O06295 as the uniquename or UniProtId. We the return the score, sorted in descending order, the UniProtID, and the ProteinName. MATCH p=(protein)-[r:INTERACTS_WITH]-(:Protein {uniquename:'O06295'}) RETURN r.score as SCORE, protein.uniquename as UniProtID, protein.name as ProteinName ORDER BY r.score DESC LIMIT 10 Drugs that targets multiple proteins The following query finds drugs that target multiple proteins. MATCH(p:Protein)-[:TARGET]-(drug) WITH drug, count(p) AS ProteinSetSize, collect(protein.uniquename) AS ProteinSet WHERE ProteinSetSize > 1 RETURN drug.name AS DrugName, drug.accession AS DrugAcc, ProteinSet, ProteinSetSize ORDER BY ProteinSetSize DESC Proteins targeted by multiple drugs The following query finds proteins targeted by multiple drugs. MATCH(drug:Drug)-[:TARGET]-(protein) WITH protein, count(drug) as DrugCount, collect(drug.name) as DrugNames, protein.uniquename as Proteins, protein.function as ProteinFunctions WHERE DrugCount > 1 RETURN Proteins, ProteinFunctions, DrugCount, DrugNames ORDER BY DrugCount DESC Which proteins are likely to infer drug resistance (DR) if mutated The following query finds proteins known to be associated with DR mutations MATCH(d:Drug)--(:Variant)--(g)--(p:Protein) RETURN distinct(p.name) as Protein, g.name as Gene, d.name as Drug Which proteins are targeted by a specific drug (Isoniazid) The following query finds proteins targeted by Isoniazid. MATCH(drug:Drug {name: \"Isoniazid\"})-[r:TARGET]-(protein:Protein) RETURN drug,r,protein Which proteins are indirectly targeted by a specific drug The following query finds proteins that are indirectly targeted by Rifampicin. MATCH(drug:Drug {name: \"Rifampicin\"})--(:Variant)--(g:Gene)--(p:Protein) RETURN *","title":"Example Cypher Queries"},{"location":"example-cypher-queries/#cypher","text":"Cypher is a declarative graph query language that allows for expressive and efficient querying and updating of the graph. Cypher is designed to be simple, yet powerful; highly complicated database queries can be easily expressed, enabling you to focus on your domain, instead of getting lost in database access. Point your browser to localhost:7474 to access the Neo4j browser. On cold boot, Neo4j has nothing cached yet, and needs to go to disk for all records. Once records are cached, you will see greatly improved performance. One technique that is widely employed is to \u201cwarm the cache\u201d. To warm the cache to improve performance from cold start, run: CALL apoc.warmup.run This will load all nodes and relationships into memory. To view the schema, run: call db.schema.visualization","title":"Cypher"},{"location":"example-cypher-queries/#example-cypher-queries","text":"","title":"Example Cypher Queries"},{"location":"example-cypher-queries/#exploring-combat-tb-neodb","text":"","title":"Exploring COMBAT-TB NeoDB"},{"location":"example-cypher-queries/#label-count","text":"In Neo4j, node types are called labels. The following query counts the number of nodes per label. MATCH(node) RETURN head(labels(node)) AS label, count(*) AS count ORDER BY count DESC","title":"Label count"},{"location":"example-cypher-queries/#relationship-type-count","text":"The following query counts the number of relationships per type MATCH()-[rel]->() RETURN type(rel) AS rel_type, count(*) AS count ORDER BY count DESC","title":"Relationship type count"},{"location":"example-cypher-queries/#random-relationships","text":"The following query retrieves a random relationship of each type. The query goes through every relationship and thus may take several seconds. MATCH()-[rel]->() WITH type(rel) AS rel_type, collect(rel) AS rels WITH rels[toInteger(rand() * size(rels))] AS rel RETURN startNode(rel), rel, endNode(rel)","title":"Random relationships"},{"location":"example-cypher-queries/#querying-combat-tb-neodb","text":"","title":"Querying COMBAT-TB NeoDB"},{"location":"example-cypher-queries/#genes-that-encode-protein-limiting-to-results-to-25","text":"The following query finds genes that encode protein. MATCH(g:Gene)-[r:ENCODES]->(p:Protein) RETURN g.name as gene, p.name as protein LIMIT 25","title":"Genes that encode protein, limiting to results to 25"},{"location":"example-cypher-queries/#genes-that-encode-a-protein-that-interacts-with-a-known-drug-target","text":"The following query finds proteins that interact with known drug targets. MATCH p=(gene:Gene)-[:ENCODES]-(p1:Protein)-[i:INTERACTS_WITH]-(p2:Protein)-[:TARGET]-(drug:Drug) RETURN gene.name as Gene, i.score as Score, p2.uniquename as Interactor, drug.name as Drug ORDER BY Score DESC","title":"Genes that encode a protein that interacts with a known drug target"},{"location":"example-cypher-queries/#find-proteins-that-interact-with-a-certain-protein","text":"The following query finds proteins that interact with a protein that has O06295 as the uniquename or UniProtId. MATCH p=(:Protein {uniquename:'O06295'})-[r:INTERACTS_WITH]-(:Protein) RETURN p","title":"Find proteins that interact with a certain protein"},{"location":"example-cypher-queries/#find-the-top-10-proteins-that-interact-with-a-specific-protein-sorted-by-score","text":"The following query finds the top 10 proteins that interact with a protein that has O06295 as the uniquename or UniProtId. We the return the score, sorted in descending order, the UniProtID, and the ProteinName. MATCH p=(protein)-[r:INTERACTS_WITH]-(:Protein {uniquename:'O06295'}) RETURN r.score as SCORE, protein.uniquename as UniProtID, protein.name as ProteinName ORDER BY r.score DESC LIMIT 10","title":"Find the top 10 proteins that interact with a specific protein sorted by score"},{"location":"example-cypher-queries/#drugs-that-targets-multiple-proteins","text":"The following query finds drugs that target multiple proteins. MATCH(p:Protein)-[:TARGET]-(drug) WITH drug, count(p) AS ProteinSetSize, collect(protein.uniquename) AS ProteinSet WHERE ProteinSetSize > 1 RETURN drug.name AS DrugName, drug.accession AS DrugAcc, ProteinSet, ProteinSetSize ORDER BY ProteinSetSize DESC","title":"Drugs that targets multiple proteins"},{"location":"example-cypher-queries/#proteins-targeted-by-multiple-drugs","text":"The following query finds proteins targeted by multiple drugs. MATCH(drug:Drug)-[:TARGET]-(protein) WITH protein, count(drug) as DrugCount, collect(drug.name) as DrugNames, protein.uniquename as Proteins, protein.function as ProteinFunctions WHERE DrugCount > 1 RETURN Proteins, ProteinFunctions, DrugCount, DrugNames ORDER BY DrugCount DESC","title":"Proteins targeted by multiple drugs"},{"location":"example-cypher-queries/#which-proteins-are-likely-to-infer-drug-resistance-dr-if-mutated","text":"The following query finds proteins known to be associated with DR mutations MATCH(d:Drug)--(:Variant)--(g)--(p:Protein) RETURN distinct(p.name) as Protein, g.name as Gene, d.name as Drug","title":"Which proteins are likely to infer drug resistance (DR) if mutated"},{"location":"example-cypher-queries/#which-proteins-are-targeted-by-a-specific-drug-isoniazid","text":"The following query finds proteins targeted by Isoniazid. MATCH(drug:Drug {name: \"Isoniazid\"})-[r:TARGET]-(protein:Protein) RETURN drug,r,protein","title":"Which proteins are targeted by a specific drug (Isoniazid)"},{"location":"example-cypher-queries/#which-proteins-are-indirectly-targeted-by-a-specific-drug","text":"The following query finds proteins that are indirectly targeted by Rifampicin. MATCH(drug:Drug {name: \"Rifampicin\"})--(:Variant)--(g:Gene)--(p:Protein) RETURN *","title":"Which proteins are indirectly targeted by a specific drug"},{"location":"graph-algorithms/","text":"Graph Algorithms in NeoDB The neo4j-graph-algorithms library provides efficiently implemented, parallel versions of common graph algorithms for Neo4j, exposed as Cypher procedures. In this section, we are going to use some of the centrality measures employed by Melak and Gakkahar to identify the most central proteins from protein\u2013protein interaction network of Mycobacterium tuberculosis H37Rv which was retrieved from STRING by hypothesizing these proteins would be important to alter the function of the network ( Melak and Gakkahar, 2014 ). This is to illustrate the utility of graph analytics. It is not meant to replicate the work done in the above mentioned paper. Centrality algorithms Centrality algorithms determine the importance of distinct nodes in a network. Degree Centrality: Direct Importance Degree centrality measures the number of incoming and outgoing relationships from a node. The degree or connectivity of a Protein is the number of links connected to it, that is, the number of its interacting neighbours which is determined by counting the number of edges connected to a node. The degree centrality measure ranks the potential of an individual node in the network based on its connectivity and it provides an indicator of its influence on the biological processes occurring in the organism, meaning that a protein with higher degree tends to contribute to several processes, and potentially be a key protein in the functioning of the system ( Melak and Gakkahar, 2014 ). The following query returns Proteins that have the most incoming interactors. CALL algo.degree.stream(\"Protein\", \"INTERACTS_WITH\", {direction: \"incoming\"}) YIELD nodeId, score RETURN algo.asNode(nodeId).uniquename AS protein, algo.asNode(nodeId).name AS name, score AS incoming_interactors ORDER BY incoming_interactors DESC The following query returns Proteins that have the most outgoing interactors. CALL algo.degree.stream(\"Protein\", \"INTERACTS_WITH\", {direction: \"outgoing\"}) YIELD nodeId, score RETURN algo.asNode(nodeId).uniquename AS protein, algo.asNode(nodeId).name AS name, score AS outgoing_interactors ORDER BY outgoing_interactors DESC Closeness Centrality: Average Farness (inverse distance) Closeness centrality is a way of detecting nodes that are able to spread information very efficiently through a graph. The closeness centrality of a node measures the centrality of a node based on how close it is to other nodes in the network. The smaller the total distance of a node to other nodes, the higher its closeness is. The distance between two nodes is defined as the length of the shortest path between them. We calculate closeness centrality measure for a node by inverting the sum of the distances from it to other nodes in the network. The closeness measure is high for a Protein that is central since it has a shorter distance on average to other proteins. CALL algo.closeness.stream(\"Protein\", \"INTERACTS_WITH\") YIELD nodeId, centrality RETURN algo.asNode(nodeId).uniquename AS protein, centrality ORDER BY centrality DESC LIMIT 20; Betweenness Centrality: Shortest (weighted) Path Betweenness centrality is a way of detecting the amount of influence a node has over the flow of information in a graph. It is often used to find nodes that serve as a bridge from one part of a graph to another. The betweenness centrality of a Protein in a functional network is a metric that expresses its influence relative to other proteins within the network. It is based on the proportion of shortest paths between other proteins passing through the protein target and shows the importance of a protein for the transmission of information between other proteins in the network. This metric provides an indication of the number of pair-wise proteins connected indirectly by the protein target through their direct functional connections ( Melak and Gakkahar, 2014 ). Proteins with higher rank of betweenness are expected to ensure the connectivity between proteins in the functional network and are able to bridge or disconnect connected components. CALL algo.betweenness.stream(\"Protein\", \"INTERACTS_WITH\", {direction:'out'}) YIELD nodeId, centrality MATCH (protein:Protein) WHERE id(protein) = nodeId RETURN protein.uniquename AS protein,centrality ORDER BY centrality DESC; Transitive Importance Eigenvector Centrality Like degree centrality, the Eigenvector Centrality algorithm measures a node\u2019s transitive influence by counting the number of links it has to other nodes within the network. However, it goes a step further by also taking into account how well connected a node is, and how many links their connections have, and so on through the network. A high Eigenvector centrality score indicates a strong influence over other nodes in the network. It is useful because it indicates not just direct influence, but also implies influence over nodes more than one \u2018hop\u2019 away. The following will run the algorithm and stream results normalized using max (divide all scores by the maximum score). CALL algo.eigenvector.stream(\"Protein\", \"INTERACTS_WITH\", {normalization: \"max\"}) YIELD nodeId, score RETURN algo.asNode(nodeId).uniquename AS protein,score ORDER BY score DESC PageRank PageRank , a variant of Eigenvector Centrality , is an algorithm that measures the transitive influence or connectivity of nodes. It uses links between nodes as a measure of importance. Each node in a network is assigned a score based upon its number of incoming links (its \u2018indegree\u2019). These links are also weighted depending on the relative score of its originating node. Nodes with many incoming links are influential, and nodes to which they are connected share some of that influence. Like Eigenvector centrality, PageRank can help uncover influential or important nodes whose reach extends beyond just their direct connections. We can use this algorithm to find important Proteins based not only on whether they INTERACT_WITH a lots of Proteins , but whether those Proteins are themselves important. The following will run the algorithm and stream results. CALL algo.pageRank.stream(\"Protein\", \"INTERACTS_WITH\", {iterations:20, dampingFactor:0.85}) YIELD nodeId, score RETURN algo.asNode(nodeId).uniquename AS protein,score ORDER BY score DESC","title":"Graph Algorithms in NeoDB"},{"location":"graph-algorithms/#graph-algorithms-in-neodb","text":"The neo4j-graph-algorithms library provides efficiently implemented, parallel versions of common graph algorithms for Neo4j, exposed as Cypher procedures. In this section, we are going to use some of the centrality measures employed by Melak and Gakkahar to identify the most central proteins from protein\u2013protein interaction network of Mycobacterium tuberculosis H37Rv which was retrieved from STRING by hypothesizing these proteins would be important to alter the function of the network ( Melak and Gakkahar, 2014 ). This is to illustrate the utility of graph analytics. It is not meant to replicate the work done in the above mentioned paper.","title":"Graph Algorithms in NeoDB"},{"location":"graph-algorithms/#centrality-algorithms","text":"Centrality algorithms determine the importance of distinct nodes in a network.","title":"Centrality algorithms"},{"location":"graph-algorithms/#degree-centrality-direct-importance","text":"Degree centrality measures the number of incoming and outgoing relationships from a node. The degree or connectivity of a Protein is the number of links connected to it, that is, the number of its interacting neighbours which is determined by counting the number of edges connected to a node. The degree centrality measure ranks the potential of an individual node in the network based on its connectivity and it provides an indicator of its influence on the biological processes occurring in the organism, meaning that a protein with higher degree tends to contribute to several processes, and potentially be a key protein in the functioning of the system ( Melak and Gakkahar, 2014 ). The following query returns Proteins that have the most incoming interactors. CALL algo.degree.stream(\"Protein\", \"INTERACTS_WITH\", {direction: \"incoming\"}) YIELD nodeId, score RETURN algo.asNode(nodeId).uniquename AS protein, algo.asNode(nodeId).name AS name, score AS incoming_interactors ORDER BY incoming_interactors DESC The following query returns Proteins that have the most outgoing interactors. CALL algo.degree.stream(\"Protein\", \"INTERACTS_WITH\", {direction: \"outgoing\"}) YIELD nodeId, score RETURN algo.asNode(nodeId).uniquename AS protein, algo.asNode(nodeId).name AS name, score AS outgoing_interactors ORDER BY outgoing_interactors DESC","title":"Degree Centrality: Direct Importance"},{"location":"graph-algorithms/#closeness-centrality-average-farness-inverse-distance","text":"Closeness centrality is a way of detecting nodes that are able to spread information very efficiently through a graph. The closeness centrality of a node measures the centrality of a node based on how close it is to other nodes in the network. The smaller the total distance of a node to other nodes, the higher its closeness is. The distance between two nodes is defined as the length of the shortest path between them. We calculate closeness centrality measure for a node by inverting the sum of the distances from it to other nodes in the network. The closeness measure is high for a Protein that is central since it has a shorter distance on average to other proteins. CALL algo.closeness.stream(\"Protein\", \"INTERACTS_WITH\") YIELD nodeId, centrality RETURN algo.asNode(nodeId).uniquename AS protein, centrality ORDER BY centrality DESC LIMIT 20;","title":"Closeness Centrality: Average Farness (inverse distance)"},{"location":"graph-algorithms/#betweenness-centrality-shortest-weighted-path","text":"Betweenness centrality is a way of detecting the amount of influence a node has over the flow of information in a graph. It is often used to find nodes that serve as a bridge from one part of a graph to another. The betweenness centrality of a Protein in a functional network is a metric that expresses its influence relative to other proteins within the network. It is based on the proportion of shortest paths between other proteins passing through the protein target and shows the importance of a protein for the transmission of information between other proteins in the network. This metric provides an indication of the number of pair-wise proteins connected indirectly by the protein target through their direct functional connections ( Melak and Gakkahar, 2014 ). Proteins with higher rank of betweenness are expected to ensure the connectivity between proteins in the functional network and are able to bridge or disconnect connected components. CALL algo.betweenness.stream(\"Protein\", \"INTERACTS_WITH\", {direction:'out'}) YIELD nodeId, centrality MATCH (protein:Protein) WHERE id(protein) = nodeId RETURN protein.uniquename AS protein,centrality ORDER BY centrality DESC;","title":"Betweenness Centrality: Shortest (weighted) Path"},{"location":"graph-algorithms/#transitive-importance","text":"","title":"Transitive Importance"},{"location":"graph-algorithms/#eigenvector-centrality","text":"Like degree centrality, the Eigenvector Centrality algorithm measures a node\u2019s transitive influence by counting the number of links it has to other nodes within the network. However, it goes a step further by also taking into account how well connected a node is, and how many links their connections have, and so on through the network. A high Eigenvector centrality score indicates a strong influence over other nodes in the network. It is useful because it indicates not just direct influence, but also implies influence over nodes more than one \u2018hop\u2019 away. The following will run the algorithm and stream results normalized using max (divide all scores by the maximum score). CALL algo.eigenvector.stream(\"Protein\", \"INTERACTS_WITH\", {normalization: \"max\"}) YIELD nodeId, score RETURN algo.asNode(nodeId).uniquename AS protein,score ORDER BY score DESC","title":"Eigenvector Centrality"},{"location":"graph-algorithms/#pagerank","text":"PageRank , a variant of Eigenvector Centrality , is an algorithm that measures the transitive influence or connectivity of nodes. It uses links between nodes as a measure of importance. Each node in a network is assigned a score based upon its number of incoming links (its \u2018indegree\u2019). These links are also weighted depending on the relative score of its originating node. Nodes with many incoming links are influential, and nodes to which they are connected share some of that influence. Like Eigenvector centrality, PageRank can help uncover influential or important nodes whose reach extends beyond just their direct connections. We can use this algorithm to find important Proteins based not only on whether they INTERACT_WITH a lots of Proteins , but whether those Proteins are themselves important. The following will run the algorithm and stream results. CALL algo.pageRank.stream(\"Protein\", \"INTERACTS_WITH\", {iterations:20, dampingFactor:0.85}) YIELD nodeId, score RETURN algo.asNode(nodeId).uniquename AS protein,score ORDER BY score DESC","title":"PageRank"},{"location":"installation/","text":"Using docker The fastest was to get a local installation is by using docker and docker-compose Prerequisites docker docker-compose Assuming you have docker and docker-compose installed. $ git clone https://github.com/COMBAT-TB/combat-tb-db.git $ cd combat-tb-db $ docker-compose up --build -d Building Once the server is running, visit http://localhost:7474 . You shall see the following guide to get you familiar with the database. Standalone Download and extract the latest release of Neo4j from the Neo4j Download Center and follow the relevant installation instructions from the operators manual . cd into Neo4j directory: $ cd ~/Downloads/neo4j-community-3.5.4 Download the NeoDB browser guide and configure Neo4j accordingly: $ pwd # $HOME/Downloads/neo4j-community-3.5.4 $ wget https://raw.githubusercontent.com/COMBAT-TB/combat-tb-db/master/guides/combattb_neodb.html \\ -P data/guides/ \\ && echo 'dbms.security.auth_enabled=false' >> conf/neo4j.conf \\ && echo 'dbms.allow_upgrade=true' >> conf/neo4j.conf \\ && echo 'dbms.security.procedures.unrestricted=apoc.*,algo.*' >> conf/neo4j.conf \\ && echo 'dbms.security.procedures.whitelist=apoc.*, algo.*' >> conf/neo4j.conf \\ && echo 'dbms.unmanaged_extension_classes=extension.web=/guides' >> conf/neo4j.conf \\ && echo 'org.neo4j.server.guide.directory=data/guides' >> conf/neo4j.conf \\ && echo 'browser.post_connect_cmd=config; play http://localhost:7474/guides/combattb_neodb.html' >> conf/neo4j.conf \\ && echo 'browser.remote_content_hostname_whitelist=*' >> conf/neo4j.conf Download and extract the COMBAT-TB NeoDB : $ pwd # $HOME/Downloads/neo4j-community-3.5.4 $ wget \"https://ndownloader.figshare.com/files/15192035\" \\ -O neodb_db_data.tar.bz2 $ tar -xjvf neodb_db_data.tar.bz2 $ cp -R databases/ data/ Download the APOC Procedures and Graph Algorithms binary jars, and place then in the $NEO4J_HOME/plugins folder: $ pwd # $HOME/Downloads/neo4j-community-3.5.4 $ export NEO4J_CONTRIB=\"https://github.com/neo4j-contrib\" $ wget \"${NEO4J_CONTRIB}/neo4j-graph-algorithms/releases/download/3.5.4.0/graph-algorithms-algo-3.5.4.0.jar\" -P plugins/ \\ && wget \"${NEO4J_CONTRIB}/neo4j-apoc-procedures/releases/download/3.5.0.3/apoc-3.5.0.3-all.jar\" -P plugins/ Run Neo4j as a background process: $ pwd # $HOME/Downloads/neo4j-community-3.5.4 $ bin/neo4j start and visit http://localhost:7474 .","title":"Installation"},{"location":"installation/#using-docker","text":"The fastest was to get a local installation is by using docker and docker-compose Prerequisites docker docker-compose Assuming you have docker and docker-compose installed. $ git clone https://github.com/COMBAT-TB/combat-tb-db.git $ cd combat-tb-db $ docker-compose up --build -d Building Once the server is running, visit http://localhost:7474 . You shall see the following guide to get you familiar with the database.","title":"Using docker"},{"location":"installation/#standalone","text":"Download and extract the latest release of Neo4j from the Neo4j Download Center and follow the relevant installation instructions from the operators manual . cd into Neo4j directory: $ cd ~/Downloads/neo4j-community-3.5.4 Download the NeoDB browser guide and configure Neo4j accordingly: $ pwd # $HOME/Downloads/neo4j-community-3.5.4 $ wget https://raw.githubusercontent.com/COMBAT-TB/combat-tb-db/master/guides/combattb_neodb.html \\ -P data/guides/ \\ && echo 'dbms.security.auth_enabled=false' >> conf/neo4j.conf \\ && echo 'dbms.allow_upgrade=true' >> conf/neo4j.conf \\ && echo 'dbms.security.procedures.unrestricted=apoc.*,algo.*' >> conf/neo4j.conf \\ && echo 'dbms.security.procedures.whitelist=apoc.*, algo.*' >> conf/neo4j.conf \\ && echo 'dbms.unmanaged_extension_classes=extension.web=/guides' >> conf/neo4j.conf \\ && echo 'org.neo4j.server.guide.directory=data/guides' >> conf/neo4j.conf \\ && echo 'browser.post_connect_cmd=config; play http://localhost:7474/guides/combattb_neodb.html' >> conf/neo4j.conf \\ && echo 'browser.remote_content_hostname_whitelist=*' >> conf/neo4j.conf Download and extract the COMBAT-TB NeoDB : $ pwd # $HOME/Downloads/neo4j-community-3.5.4 $ wget \"https://ndownloader.figshare.com/files/15192035\" \\ -O neodb_db_data.tar.bz2 $ tar -xjvf neodb_db_data.tar.bz2 $ cp -R databases/ data/ Download the APOC Procedures and Graph Algorithms binary jars, and place then in the $NEO4J_HOME/plugins folder: $ pwd # $HOME/Downloads/neo4j-community-3.5.4 $ export NEO4J_CONTRIB=\"https://github.com/neo4j-contrib\" $ wget \"${NEO4J_CONTRIB}/neo4j-graph-algorithms/releases/download/3.5.4.0/graph-algorithms-algo-3.5.4.0.jar\" -P plugins/ \\ && wget \"${NEO4J_CONTRIB}/neo4j-apoc-procedures/releases/download/3.5.0.3/apoc-3.5.0.3-all.jar\" -P plugins/ Run Neo4j as a background process: $ pwd # $HOME/Downloads/neo4j-community-3.5.4 $ bin/neo4j start and visit http://localhost:7474 .","title":"Standalone"}]}